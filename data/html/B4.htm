<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"> <html><!--
 Archive processed by SingleFile 
 url: https://informatics.msk.ru/mod/statements/print3.php?id=33415 
 saved date: Tue Aug 21 2018 21:39:07 GMT+0300 (MSK) 
--><meta charset=utf-8>
<title>Параллель B. Дейкстра</title>
<style>.problem-statement { margin: 0.5em; font-family: verdana; line-height: 1.5em; font-size: 14px; }.problem-statement p { margin: 0px 0px 1em; }.problem-statement .legend { margin-bottom: 1em; }.problem-statement .section-title { font-family: arial; font-size: 115%; font-weight: bold; }.problem-statement .output-specification { margin-bottom: 1em; }.problem-statement .sample-tests .input, .problem-statement .sample-tests .output { border: 1px solid rgb(136, 136, 136); }.problem-statement .sample-tests .output { margin-bottom: 1em; position: relative; top: -1px; }.problem-statement .sample-tests pre { line-height: 1.25em; padding: 0.25em; margin: 0px; background-color: rgb(239, 239, 239); }.problem-statement .sample-tests .title { font-family: arial; padding: 0.25em; border-bottom: 1px solid rgb(136, 136, 136); text-transform: lowercase; font-weight: bold; }.problem-statement .tex-formula { vertical-align: middle; margin: 0px; border: medium none; position: relative; bottom: 2px; }.problem-statement .tex-span { font-size: 125%; font-family: "times new roman"; }.problem-statement .tex-font-style-tt { font-size: 110%; font-family: "courier new"; }</style>
<meta http-equiv=Content-Type content="text/html; charset=utf-8">
<meta http-equiv=Content-Type content="text/html; charset=">
<meta name=description content="Параллель B. Дейкстра">
<style>h1, h2, h3, h4, h5, h6 { margin-left: 0px; font-family: "Times New Roman", Times, serif; break-after: avoid; break-inside: avoid; }.statements_title { margin-left: -40px; font-family: Tahoma, Verdana, Arial, Helvetica, sans-serif; font-size: 3em; font-weight: bold; margin-top: 120px; margin-bottom: 30px; text-align: center; }.statements_summary { margin-left: -40px; text-align: center; margin-bottom: 120px; }.statements_chapter_title { font-family: Tahoma, Verdana, Arial, Helvetica, sans-serif; text-align: left; font-size: 1.7em; font-weight: bold; border-style: solid; border-width: 0px 0px 1px; margin-left: 0px; margin-bottom: 20px; }.statements_chapter { break-before: page; }body { margin-left: 50px; margin-right: 10px; color: rgb(0, 0, 0); background-color: rgb(255, 255, 255); font-family: "Times New Roman", Times, serif; font-size: 1em; font-weight: normal; text-decoration: none; }font { color: rgb(0, 0, 0); background-color: rgb(238, 238, 238); font-family: "Times New Roman", Times, serif; font-size: 1em; font-weight: normal; text-decoration: none; }.typeset { font-family: serif; font-style: normal; font-weight: normal; line-height: normal; text-indent: 0px; }span.typeset { text-align: left; }.typeset span { text-align: left; border: 0px; margin: 0px; padding: 0px; }.typeset .blank { display: inline-block; overflow: hidden; border: 0px none; width: 0px; height: 0px; }.typeset .spacer { display: inline-block; }#jsMath_message { position: fixed; bottom: 1px; left: 2px; background-color: rgb(230, 230, 230); border: 1px solid rgb(149, 149, 149); margin: 0px; padding: 1px 8px; z-index: 102; color: black; font-size: small; width: auto; }#jsMath_button { position: fixed; bottom: 1px; right: 2px; background-color: white; border: 1px solid rgb(149, 149, 149); margin: 0px; padding: 0px 3px 1px; z-index: 102; color: black; text-decoration: none; font-size: x-small; width: auto; cursor: pointer; }#jsMath_button * { padding: 0px; border: 0px; margin: 0px; line-height: normal; font-size: inherit; font-style: inherit; font-family: inherit; }@media print{#jsMath_button { display: none; }}.typeset .scale { font-size: 120%; }.typeset .icmmi10 { font-family: serif; font-style: italic; }</style><link type=image/x-icon rel="shortcut icon" href=data:image/x-icon;base64,></head> <body><div id=jsMath_message style=visibility:hidden;>Processing Math: Done</div><div id=jsMath_button title=" Open jsMath Control Panel "><span onclick=jsMath.Controls.Panel()>jsMath</span></div><div style="position:fixed;bottom:1px;left:2px;background-color:#e6e6e6;border:1px solid #959595;margin:0;padding:1px 8px;z-index:102;color:black;font-size:75%;width:auto;visibility:hidden;"></div> <a name=top></a> <p class=statements_title>Параллель B. Дейкстра</p> <p class=statements_summary></p>  <div class=statements_toc_alpha><a name=toc></a><p class=statements_chapter_title>Список задач<ul><li><a href=#ch3494><b>Задача A.</b> Алгоритм Дейкстры за <span class=typeset><nobr><span class=scale><span class=icmmi10>Mlo</span><span class=icmmi10>g</span><span class=spacer style=margin-left:.035em></span><span class=icmmi10>N</span><span class=spacer style=margin-left:.109em></span></span></nobr></span></a><li><a href=#ch6><b>Задача B.</b> Дейкстра: восстановление пути</a><li><a href=#ch169><b>Задача C.</b> Заправки</a><li><a href=#ch1967><b>Задача D.</b> Транспортировка</a></ul></div><hr><div class=statements_chapter><h1><a name=ch3494>Алгоритм Дейкстры за <span class=typeset><nobr><span class=scale><span style=position:relative;><span style=position:absolute;top:0;left:0;><span class=icmmi10>Mlo</span><span class=icmmi10>g</span><span class=spacer style=margin-left:.035em></span><span class=icmmi10>N</span><span class=spacer style=margin-left:.109em></span>&nbsp;</span><span class=blank style=width:2.916em;height:.937em;></span></span><span class=blank style=height:1.040em;vertical-align:-0.25em></span></span></nobr></span></a></h1><p class=statements_chapter_title><b>Задача A.</b> Алгоритм Дейкстры за <span class=typeset><nobr><span class=scale><span style=position:relative;><span style=position:absolute;top:0;left:0;><span class=icmmi10>Mlo</span><span class=icmmi10>g</span><span class=spacer style=margin-left:.035em></span><span class=icmmi10>N</span><span class=spacer style=margin-left:.109em></span>&nbsp;</span><span class=blank style=width:2.911em;height:.919em;></span></span><span class=blank style=height:1.040em;vertical-align:-0.25em></span></span></nobr></span><div class=problem-statement><div class=legend><p>Напишите программу, которая будет находить расстояния в неориентированном взвешенном графе с неотрицательными длинами ребер, от указанной вершины до всех остальных. Программа должна работать быстро для больших разреженных графов.</p></div><p><div class=input-specification><div class=section-title>Входные данные</div><p>В первой строке входных данных задано число NUM — количество различных запусков алгоритма Дейкстры (на разных графах). Далее следуют NUM блоков, каждый из которых имеет следующую структуру.<p>Первая строка блока содержит два числа <span class=tex-span><i>N</i></span> и <span class=tex-span><i>M</i></span>, разделенные пробелом — количество вершин и количество ребер графа. Далее следуют <span class=tex-span><i>M</i></span> строк, каждая из которых содержит по три целых числа, разделенные пробелами. Первые два из них в пределах от 0 до <span class=tex-span><i>N</i></span>–1 каждое и обозначают концы соответствующего ребра, третье — в пределах от 0 до 20000 и обозначает длину этого ребра. Далее, в последней строке блока, записанное единственное число от 0 до <span class=tex-span><i>N</i></span>–1 — вершина, расстояния от которой надо искать.<p>Количество различных графов в одном тесте NUM не&nbsp;превышает&nbsp;5. Количество вершин не&nbsp;превышает 60000, рёбер — 200000.</p></div><p><div class=output-specification><div class=section-title>Выходные данные</div><p>Выведите на стандартный выход (экран) NUM строк, в каждой из которых по <span class=tex-span><i>N</i><sub class=lower-index><i>i</i></sub></span> чисел, разделенных пробелами — расстояния от указанной начальной вершины взвешенного неориентированного графа до его 0-й, 1-й, 2-й и&nbsp;т.&nbsp;д. вершин (допускается лишний пробел после последнего числа). Если некоторая вершина недостижима от указанной начальной, вместо расстояния выводите число 2009000999 (гарантировано, что все реальные расстояния меньше).</p></div><p> <div class=note><div class=section-title>Примечание</div><p>Убедитесь, что программа правильно учитывает, что за один запуск следует обработать несколько различных графов.<p>Указания. <p>Чтобы обеспечить асимптотическую оценку времени выполнения <img align=middle class=tex-formula src="data:image/png;base64,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">, следует:<p>1. Представлять граф списками смежности и делать перебор соседей аналогично задаче «Поиск в ширину – 1».<p>2. При выборе, какая именно вершина статуса&nbsp;1 имеет наименьшую оценку расстояния, пользоваться пирамидой.<p>Поскольку списками смежности следует подать взвешенный граф, то граф уже нельзя представить как <span class=tex-font-style-tt>vector&lt;list&lt;int>&nbsp;></span>. Элементами списков должны быть структуры из двух полей (вершина, куда идет ребро, и длина ребра). Например, можно объявить тип<p><span class=tex-font-style-tt>struct edge</span><p><span class=tex-font-style-tt>{</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;unsigned int v; / / номер вершины, куда идет ребро</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;unsigned int len; / / длина этого ребра</span><p><span class=tex-font-style-tt>};</span><p>и после этого граф в целом можно будет представить как <span class=tex-font-style-tt>vector&lt;list&lt;edge>&nbsp;></span>. При переборе соседей вершины <span class=tex-font-style-tt>curr</span> с&nbsp;помощью цикла<p><span class=tex-font-style-tt>for(list&lt;edge>::iterator w = graph[curr].begin() ;</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;w != graph[curr].end() ; w++)</span> &nbsp; <span class=tex-font-style-tt>w</span> будет итератором уже не списка чисел, а&nbsp;списка структур; поэтому, чтобы узнать номер вершины, куда ведет соответствующее ребро, следует обратиться к полю <span class=tex-font-style-tt>w->v</span>, а&nbsp;чтобы узнать вес этого ребра — к полю <span class=tex-font-style-tt>w->len</span>.<p>Поскольку нужно находить вершину с минимальной оценкой, в&nbsp;пирамиду следует помещать оценки и придерживаться того варианта пирамиды, где каждая вершина меньше-равна (а&nbsp;не больше-равна) своих сыновей. Причём, если хранить в&nbsp;пирамиде лишь оценки расстояний, нельзя будет быстро выяснять, какая вершина имеет эту оценку. Поэтому в пирамиде также надо хранить структуры из двух полей: номер вершины и её оценка. Например,<p><span class=tex-font-style-tt>struct estdata</span><p><span class=tex-font-style-tt>{</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;unsigned int v; // номер вершины</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;unsigned int est; // оценка расстояния этой вершины</span><p><span class=tex-font-style-tt>};</span><p>Тогда пирамида может быть объявлена как переменная типа <span class=tex-font-style-tt>priority_queue&lt;estdata></span>. Чтобы программу с переменной такого типа можно было хотя&nbsp;бы скомпилировать, необходимо задать правило, по которому будет определяться, какой из двух элементов типа <span class=tex-font-style-tt>estdata</span> меньше и какой больше. Ведь не зная, что больше и что меньше, невозможно поддерживать основное свойство <span class=tex-font-style-tt>priority_queue</span> (каждый элемент больше-равен своих сыновей).<p>Один из способов задать такое правило — перегрузить (overload) операцию сравнения путем написания функции<p><span class=tex-font-style-tt>bool operator &lt; (const estdata &amp;d1, const estdata &amp;d2)</span><p><span class=tex-font-style-tt>{</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;return d1.est > d2.est;</span><p><span class=tex-font-style-tt>}</span><p>где <span class=tex-font-style-tt>estdata</span> — имя типа, для которого задаем правило сравнения; перегружать надо именно <span class=tex-font-style-tt>operator&nbsp;&lt;</span> (а&nbsp;не <span class=tex-font-style-tt>operator&nbsp;></span> и не <span class=tex-font-style-tt>operator&nbsp;&lt;=</span>); в теле функции, которая задает правило для&nbsp;<span class=tex-font-style-tt>&lt;</span>, в&nbsp;данном случае пишем&nbsp;<span class=tex-font-style-tt>></span>, так как <span class=tex-font-style-tt>priority_queue</span> размещает в корне максимальный элемент, а&nbsp;нам нужно эффективно извлекать вершину с&nbsp;минимальной оценкой.<p>Еще одну мелкую проблему создает то, что при выполнении алгоритма Дейкстры возможно изменение оценки расстояния до вершины статуса&nbsp;1 (когда новый маршрут оказывается короче найденного ранее). Шаблон <span class=tex-font-style-tt>priority_queue</span> не&nbsp;позволяет изменять значения элемента, вставленного в&nbsp;пирамиду ранее. Поэтому при изменении оценки на меньшую приходится вставлять в пирамиду еще один элемент с меньшим полем&nbsp;<span class=tex-font-style-tt>est</span> и таким&nbsp;же полем&nbsp;<span class=tex-font-style-tt>v</span>.<p>Благодаря правилам выбора элементов из пирамиды, первой среди всех структур с одинаковым полем&nbsp;<span class=tex-font-style-tt>v</span> будет обработано ту, у&nbsp;которой минимальное поле&nbsp;<span class=tex-font-style-tt>est</span>. Благодаря этому, повторные вставки никак не влияют ни на правильность алгоритма, ни на асимптотические оценки <img align=middle class=tex-formula src="data:image/png;base64,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"> времени, <span class=tex-span>Θ(<i>M</i>)</span>&nbsp;памяти. Нужно только при вынимании очередного элемента из пирамиды проверять, а&nbsp;не вынимали&nbsp;ли эту вершину раньше. Причем, делать эту проверку просто: если вершина имеет статус&nbsp;1, ее вынули впервые; если статус&nbsp;2 — ее вынимали и обрабатывали прежде.<p>Итак, находить, какую вершину следует сделать новой текущей, можно, например, так:<p><span class=tex-font-style-tt>while (!the_heap.empty() &amp;&amp; st[the_heap.top().v] == 2)</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;the_heap.pop (); // пропускаем все структуры, соответствующие</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// повторным вхождением уже обработанных элементов</span><p><span class=tex-font-style-tt>if(the_heap.empty()) // пирамида пуста — значит, все достижимые вершины</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;break; // уже обработаны и пора завершать основной цикл</span><p><span class=tex-font-style-tt>curr = the_heap.top().v; // запоминаем как новую текущую вершину</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// с минимальной оценкой;</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// раз дошли сюда после предыдущих while и if,</span><p><span class=tex-font-style-tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// она существует и ещё не обработана</span><p><span class=tex-font-style-tt>the_heap.pop(); // вынимаем запомненную в curr вершину из пирамиды</span><p>Здесь <span class=tex-font-style-tt>the_heap</span> — пирамида (переменная типа <span class=tex-font-style-tt>priority_queue&lt;estdata></span>), <span class=tex-font-style-tt>st</span> — вектор (массив) статусов вершин, <span class=tex-font-style-tt>curr</span> — номер текущей (для следующей итерации большого цикла) вершины.<p>Если писать пирамиду вручную, можно не вставлять в пирамиду новый элемент с таким же полем&nbsp;<span class=tex-font-style-tt>v</span>, а&nbsp;уменьшать поле <span class=tex-font-style-tt>est</span> ранее вставленного элемента. Но&nbsp;для этого надо постоянно поддерживать информацию о том, где именно в&nbsp;пирамиде (в&nbsp;каком по номеру элемента массива) находится каждая вершина статуса&nbsp;1. Это достаточно сложно, и этого часто все равно не&nbsp;делают (т.&nbsp;е. все равно вставляют в&nbsp;пирамиду копии).<p>Бонусное задание. Докажите, что повторная вставка элементов с тем же полем&nbsp;<span class=tex-font-style-tt>v</span> действительно не&nbsp;ухудшает асимптотические оценки <img align=middle class=tex-formula src="data:image/png;base64,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"> времени, <span class=tex-span>Θ(<i>M</i>)</span>&nbsp;памяти.</p></div></div> <div class=problem-statement><div class=sample-tests><div class=section-title>Примеры</div><div class=sample-test><div class=input><div class=title>Входные данные</div><pre class=content>1
5 7
1 2 5
1 3 2
2 3 4
2 4 3
3 4 6
0 3 20
0 4 10
1
</pre></div><div class=output><div class=title>Выходные данные</div><pre class=content>18 0 5 2 8 
</pre></div></div></div></div></div><hr><div class=statements_chapter><h1><a name=ch6>Дейкстра: восстановление пути</a></h1><p class=statements_chapter_title><b>Задача B.</b> Дейкстра: восстановление пути<div class=problem-statement> <div class=legend> <p> Дан ориентированный взвешенный граф. Найдите кратчайший путь от одной заданной вершины до другой. </p> </div> <div class=input-specification> <div class=section-title> Входные данные </div> <p> В первой строке содержатся три числа: <em>N</em>, <em>S</em> и <em>F</em> (1<span style=font-size:12pt>≤</span><font face="Arial, sans-serif"><font style=font-size:11pt size=2><em>N<font face="Symbol, serif"><span lang=en-US></span></font></em></font></font><span style=font-size:12pt>≤</span><font face="Arial, sans-serif"><font style=font-size:11pt size=2><font face="Symbol, serif"><span lang=en-US></span></font>100, 1<font face="Symbol, serif"><span lang=en-US></span></font></font></font><span style=font-size:12pt>≤</span><font face="Arial, sans-serif"><font style=font-size:11pt size=2><font face="Symbol, serif"><span lang=en-US></span></font><em>S</em>, <em>F</em></font></font><span style=font-size:12pt>≤</span><font face="Arial, sans-serif"><font style=font-size:11pt size=2><font face="Symbol, serif"><span lang=en-US></span></font><em>N</em>), где <em>N</em> – количество вершин графа, <em>S</em> – начальная вершина, а <em>F –</em> конечная. В следующих <em>N</em> строках вводится по <em>N</em> чисел, не превосходящих 100, – матрица смежности графа, где -1 означает отсутствие ребра между вершинами, а любое неотрицательное число – присутствие ребра данного веса. На главной диагонали матрицы записаны нули. </font></font></p><font face="Arial, sans-serif"><font style=font-size:11pt size=2> </font></font></div><font face="Arial, sans-serif"><font style=font-size:11pt size=2> <div class=output-specification> <div class=section-title> Выходные данные </div> <p> Требуется вывести последовательно все вершины одного (любого) из кратчайших путей, или одно число <font face="courier new,courier,monospace">-1</font>, если пути между указанными вершинами не существует. <b>Пример выходного файла ниже неправильный. Правильный пример, скорее всего, <code>2 3 1</code></b>. </p> </div> </font></font></div><font face="Arial, sans-serif"><font style=font-size:11pt size=2>
<div class=problem-statement><div class=sample-tests><div class=section-title>Примеры</div><div class=sample-test><div class=input><div class=title>Входные данные</div><pre class=content>3 2 1
0 1 1
4 0 1
2 1 0
</pre></div><div class=output><div class=title>Выходные данные</div><pre class=content>3
</pre></div></div></div></div></font></font></div><hr><div class=statements_chapter><h1><font face="Arial, sans-serif"><font style=font-size:11pt size=2><a name=ch169>Заправки</a></font></font></h1><p class=statements_chapter_title><font face="Arial, sans-serif"><font style=font-size:11pt size=2><b>Задача C.</b> Заправки</font></font><div class=problem-statement><font face="Arial, sans-serif"><font style=font-size:11pt size=2> <div class=legend> <p>В стране <em>N</em> городов, некоторые из которых соединены между собой дорогами. Для того, чтобы проехать по одной дороге, требуется один бак бензина. В каждом городе бак бензина имеет разную стоимость. Вам требуется добраться из первого города в <em>N</em>-ый, потратив как можно меньшее количество денег.</p> </div> <div class=input-specification> <div class=section-title> Входные данные </div> <p>В первой сроке вводится&nbsp;число <em>N</em> (1&lt;=<em>N</em>&lt;=100),&nbsp;в следующей&nbsp;идет <em>N</em> чисел, <em>i</em>-ое из которых задает стоимость бензина в <em>i</em>-ом городе (все числа целые из диапазона от 0 до 100). Затем идет число <em>M</em>&nbsp;– количество дорог в стране, далее идет описание самих дорог. Каждая дорога задается двумя числами&nbsp;– номерами городов, которые она соединяет. Все дороги двухсторонние (то есть по ним можно ездить как в одну, так и в другую сторону); между двумя городами всегда существует не более одной дороги; не существует дорог, ведущих из города в себя.</p> </div> <div class=output-specification> <div class=section-title> Выходные данные </div> <p>Требеутся вывести&nbsp;одно число&nbsp;– суммарную стоимость маршрута или <font face="courier new,courier,monospace">-1</font>, если добраться невозможно.</p> </div> </font></font></div><font face="Arial, sans-serif"><font style=font-size:11pt size=2> <div class=problem-statement><div class=sample-tests><div class=section-title>Примеры</div><div class=sample-test><div class=input><div class=title>Входные данные</div><pre class=content>5
3 6 1 7 6 
8
1 2
5 4
5 1
3 4
5 2
2 4
2 3
3 1</pre></div><div class=output><div class=title>Выходные данные</div><pre class=content>3</pre></div></div></div></div></font></font></div><hr><div class=statements_chapter><h1><font face="Arial, sans-serif"><font style=font-size:11pt size=2><a name=ch1967>Транспортировка</a></font></font></h1><p class=statements_chapter_title><font face="Arial, sans-serif"><font style=font-size:11pt size=2><b>Задача D.</b> Транспортировка</font></font><div class=problem-statement><font face="Arial, sans-serif"><font style=font-size:11pt size=2> <div class=legend> <p>К очередной Летней компьютерной школе было решено подготовить кружки как для школьников, так и для всех преподавателей.<p>Имея привычку делать важные дела в самый последний момент, дизайнер закончил работу над макетом за два дня до начала школы. Ещё день уйдёт у завода-изготовителя на то, чтобы изготовить кружки и нанести на них изображение. На то, чтобы довезти кружки от завода-изготовителя до ЛКШ, остаётся всего 24 часа.</p> <p>Заказ на 10000000 экземпляров кружек (а именно столько заказали организаторы), конечно же, за один рейс не увезти. Однако, за первый рейс хочется привезти максимальное количество кружек. Для перевозки был заказан один большегрузный автомобиль. Но есть один нюанс: на некоторых дорогах установлено ограничение на вес автомобиля. Поэтому если автомобиль нагрузить кружками под завязку, то, возможно, не удастся воспользоваться самым коротким маршрутом, а придётся ехать в объезд. Может случиться даже так, что из-за этого грузовик не успеет доехать до лагеря вовремя, а этого допустить никак нельзя. Итак, сколько же кружек можно погрузить в автомобиль, чтобы успеть привезти этот ценный груз вовремя, и не нарушая правил дорожного движения?</p> </div> <div class=input-specification> <div class=section-title> Входные данные </div> <p>В первой строке находятся числа n (1≤n≤500) и m - количество узловых пунктов дорожной схемы и количество дорог, соответственно. В следующих m строках находится информация о дорогах. Каждая дорога описывается в отдельной строке следующим образом. Сначала указаны номера узловых пунктов, которые соединяются данной дорогой, потом время, которое тратится на проезд по этой дороге, и, наконец, максимальный вес автомобиля, которому разрешено ехать по этой дороге. Известно, что все дороги соединяют различные пункты, причем для каждой пары пунктов есть не более одной дороги, непосредственно их соединяющей. Все числа разделены одним или несколькими пробелами.&nbsp;<p>Узловые пункты нумеруются числами от 1 до n. При этом завод по производству кружек имеет номер 1, а ЛКШ - номер n. Время проезда по дороге задано в минутах и не превосходит 1440 (24 часа). Ограничение на массу задано в граммах и не превосходит одного миллиарда. Кроме того, известно, что одна кружка весит 100 грамм, а пустой грузовик -&nbsp; 3 тонны.</p> </div> <div class=output-specification> <div class=section-title> Выходные данные </div> <p>Выведите одно число - максимальное количество кружек, которое можно привезти за первый рейс, потратив не более 24часов.</p> </div> </font></font></div><font face="Arial, sans-serif"><font style=font-size:11pt size=2>
<div class=problem-statement><div class=sample-tests><div class=section-title>Примеры</div><div class=sample-test><div class=input><div class=title>Входные данные</div><pre class=content>3 3
1 2 10 3000220
2 3 20 3000201
1 3 1 3000099
</pre></div><div class=output><div class=title>Выходные данные</div><pre class=content>2
</pre></div></div></div></div></font></font></div><font face="Arial, sans-serif"><font style=font-size:11pt size=2> </font></font><autoscroll></autoscroll>